# Cursor AI Rules - WhaleTools Platform

## Project Context
**WhaleTools** is a multi-vendor marketplace platform (similar to Amazon/Shopify) built with Next.js, Supabase, and TypeScript.

**Platform Name:** WhaleTools  
**Master Vendor:** Yacht Club (demo/reference vendor account)  
**Current Focus:** Wilson's storefront template (luxury cannabis retail theme - Flora Distro vendor)

---

## Database Access (ALWAYS AVAILABLE)
You have permanent Supabase access. Run SQL queries directly without asking user.

**Connection:**
```
postgresql://postgres:SelahEsco123!!@db.uaednwpxursknmwdeejn.supabase.co:5432/postgres
```

**Quick command:**
```bash
psql "postgresql://postgres:SelahEsco123!!@db.uaednwpxursknmwdeejn.supabase.co:5432/postgres" -c "YOUR_SQL"
```

**Flora Distro Vendor ID:** `cd2e1122-d511-4edb-be5d-98ef274b4baf`

---

## Smart Component System

### Architecture:
The project uses a **Component Registry System** where pages are built from database-configured components.

**Flow:**
1. Page route loads (e.g., `/storefront?vendor=flora-distro`)
2. `ComponentBasedPageRenderer` fetches sections & component instances from DB
3. Components rendered via `COMPONENT_MAP` in `/lib/component-registry/renderer.tsx`
4. Smart components auto-receive: `vendorId`, `vendorSlug`, `vendorName`, `vendorLogo`

### Quick Reference:
- **Full Guide:** `.cursor/SMART_COMPONENT_GUIDE.md`
- **Base Utilities:** `lib/smart-component-base.tsx`
- **Generator:** `npm run generate:smart-component`
- **Components:** `/components/component-registry/smart/`

---

## WhaleTools Design System (MANDATORY)

### Colors:
- Background: `bg-black` or `bg-[#0a0a0a]`
- Borders: `border-white/5` hover: `border-white/10`
- Text: `text-white` (headings), `text-white/60` (body), `text-white/40` (labels)

### Typography:
- **Headings:** `font-black uppercase tracking-tight` with `style={{ fontWeight: 900 }}`
- **Body:** `text-white/60 leading-relaxed`
- **Labels:** `text-white/40 uppercase tracking-[0.15em]`

### Spacing:
- Rounded: `rounded-2xl` (iOS 26 style)
- Section padding: `py-16 sm:py-20 px-4 sm:px-6`
- Card padding: `p-6 sm:p-8`

### Animations:
- Use Framer Motion with easing: `[0.22, 1, 0.36, 1]`
- Scroll-triggered with `react-intersection-observer`
- Duration: `0.6s` standard

---

## Coding Standards

### General:
- Senior-level code quality (Amazon/Apple/designer brand standards)
- Fix bugs properly, rewrite from scratch if needed
- NO MOCK/DEMO/FALLBACK DATA - only real data via API
- Clean up duplicates, test files, unnecessary files
- Double-check for syntax errors before proceeding
- NO explanations unless asked - just execute

### TypeScript:
- Always use TypeScript with proper interfaces
- Extend `SmartComponentBaseProps` for smart components
- Type all props, state, and API responses

### React/Next.js:
- Use "use client" for interactive components
- Server components by default for pages
- Mobile-first responsive design
- Use base utilities (`SmartContainers`, `SmartTypography`) for consistency

### Database:
- Run SQL directly without asking
- Always use parameterized queries
- Check for existing data before inserting
- Use `ON CONFLICT` for upserts

---

## Dev Environment

### Servers:
- Keep Next.js dev server live on same port (3000)
- No port hopping (3000, 3001, 3002 - stay on same port)
- Hot-reload should not reset scroll or state

### Git:
- NEVER push unless user explicitly asks
- NO destructive operations (force push, hard reset)
- NO skipping hooks (--no-verify)
- Check Vercel deployment status if configured

### Vercel:
- If repo has Vercel, monitor deployments after push
- Fix build errors and re-deploy if needed
- Ensure build succeeds

---

## Creating Smart Components

### Use the Generator:
```bash
npm run generate:smart-component
```

### Minimal Template:
```tsx
"use client";

import React from 'react';
import { 
  SmartComponentWrapper, 
  SmartComponentBaseProps,
  SmartTypography,
  SmartContainers
} from '@/lib/smart-component-base';

export interface SmartYourComponentProps extends SmartComponentBaseProps {
  headline?: string;
}

export function SmartYourComponent({
  vendorId,
  headline = "DEFAULT",
  animate = true
}: SmartYourComponentProps) {
  return (
    <SmartComponentWrapper animate={animate} componentName="Your Component">
      <SmartContainers.Section>
        <SmartContainers.MaxWidth>
          <SmartTypography.Headline>{headline}</SmartTypography.Headline>
        </SmartContainers.MaxWidth>
      </SmartContainers.Section>
    </SmartComponentWrapper>
  );
}
```

### Required Steps:
1. Create component file
2. Export in `index.ts`
3. Add to `COMPONENT_MAP` in `renderer.tsx`
4. Register in database via SQL

---

## Key Files

### Component System:
- `components/component-registry/smart/` - Smart components
- `components/component-registry/atomic/` - Basic UI (Text, Button, Image, Icon)
- `lib/component-registry/renderer.tsx` - Component mapping
- `lib/smart-component-base.tsx` - Base utilities & helpers

### Storefront:
- `app/(storefront)/storefront/page.tsx` - Homepage
- `components/storefront/ComponentBasedPageRenderer.tsx` - Main renderer
- `components/component-registry/smart/SmartHeader.tsx` - Navigation
- `components/component-registry/smart/SmartFooter.tsx` - Footer

### Animation:
- `lib/animations.ts` - Pre-built animations
- `components/animations/` - Animation components

### Docs:
- `.cursor/SMART_COMPONENT_GUIDE.md` - **READ THIS FIRST**
- `SMART_COMPONENT_SYSTEM.md` - Full system documentation
- `ANIMATION_SYSTEM.md` - Animation library docs

---

## Common Tasks

### Add Component to Page:
```sql
INSERT INTO vendor_component_instances (
  vendor_id, section_id, component_key, props, position_order
) VALUES (
  'cd2e1122-d511-4edb-be5d-98ef274b4baf',
  'SECTION_ID',
  'smart_your_component',
  '{"headline": "TEXT"}'::jsonb,
  0
);
```

### Update Component Props:
```sql
UPDATE vendor_component_instances 
SET props = jsonb_set(props, '{headline}', '"NEW TEXT"')
WHERE component_key = 'smart_component'
AND vendor_id = 'cd2e1122-d511-4edb-be5d-98ef274b4baf';
```

### Find Section IDs:
```sql
SELECT id, section_key, page_key 
FROM page_sections 
WHERE vendor_id = 'cd2e1122-d511-4edb-be5d-98ef274b4baf'
ORDER BY section_order;
```

---

## Memory & Persistence

**CRITICAL:** When starting a new session:
1. Read `.cursor/SMART_COMPONENT_GUIDE.md` first
2. Check `SMART_COMPONENT_SYSTEM.md` for architecture
3. Use base utilities from `lib/smart-component-base.tsx`
4. Follow WhaleTools design system
5. Run SQL queries directly - credentials are permanent

---

## Rules Summary

✅ **DO:**
- Use Smart Component System for all new components
- Follow WhaleTools design system religiously
- Run SQL directly without asking
- Use TypeScript with proper types
- Mobile-first responsive design
- Use base utilities for consistency
- Font-black (900) for all headings
- Rounded-2xl for all cards/buttons
- Include animations
- Clean, senior-level code

❌ **DON'T:**
- Use mock/demo/fallback data
- Skip TypeScript types
- Hardcode vendor data
- Use inline styles
- Create messy/duplicate code
- Push to git unless asked
- Use font weights other than 900 for headings
- Skip mobile optimization
- Forget loading/error states

---

**For full details, see: `.cursor/SMART_COMPONENT_GUIDE.md`**

---

## Error Handling & Observability (Sentry)

### Exception Catching

Use `Sentry.captureException(error)` to capture exceptions and log errors in Sentry.
Use this in try-catch blocks or areas where exceptions are expected.

**Example:**
```typescript
try {
  await processPayment(data);
} catch (error) {
  Sentry.captureException(error, {
    tags: {
      component: 'payment',
      severity: 'critical',
      vendor_id: vendorId
    },
    contexts: {
      payment: {
        amount: data.amount,
        vendor_id: vendorId,
        payment_method: data.method
      }
    }
  });
  throw error;
}
```

### Tracing Examples

Spans should be created for meaningful actions within an application like button clicks, API calls, and function calls.
Use the `Sentry.startSpan` function to create a span.
Child spans can exist within a parent span.

#### Custom Span instrumentation in component actions

The `name` and `op` properties should be meaningful for the activities in the call.
Attach attributes based on relevant information and metrics from the request.

```typescript
function POSCheckoutButton() {
  const handleCheckout = () => {
    // Create a transaction/span to measure performance
    Sentry.startSpan(
      {
        op: "ui.click",
        name: "POS Checkout Button Click",
      },
      (span) => {
        const cartTotal = calculateTotal();
        const itemCount = cart.items.length;

        // Metrics can be added to the span
        span.setAttribute("cart_total", cartTotal);
        span.setAttribute("item_count", itemCount);
        span.setAttribute("vendor_id", vendorId);

        processCheckout();
      },
    );
  };

  return (
    <button type="button" onClick={handleCheckout}>
      Complete Sale
    </button>
  );
}
```

#### Custom span instrumentation in API calls

The `name` and `op` properties should be meaningful for the activities in the call.
Attach attributes based on relevant information and metrics from the request.

```typescript
async function fetchProducts(vendorId: string) {
  return Sentry.startSpan(
    {
      op: "http.client",
      name: `GET /api/supabase/products`,
    },
    async (span) => {
      span.setAttribute("vendor_id", vendorId);

      const response = await fetch(`/api/supabase/products`, {
        headers: { 'Authorization': `Bearer ${token}` }
      });

      const data = await response.json();
      span.setAttribute("product_count", data.products.length);

      return data;
    },
  );
}
```

### Logs

Where logs are used, ensure Sentry is imported using `import * as Sentry from "@sentry/nextjs"`.
Enable logging in Sentry using `Sentry.init({ _experiments: { enableLogs: true } })`.
Reference the logger using `const { logger } = Sentry`.
Sentry offers a consoleLoggingIntegration that can be used to log specific console error types automatically without instrumenting the individual logger calls.

#### Configuration

In Next.js the client side Sentry initialization is in `instrumentation-client.ts`, the server initialization is in `sentry.server.config.ts` and the edge initialization is in `sentry.edge.config.ts`.

Initialization does not need to be repeated in other files, it only needs to happen in the files mentioned above. You should use `import * as Sentry from "@sentry/nextjs"` to reference Sentry functionality.

##### Baseline Configuration

```typescript
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,

  // Enable structured logging
  _experiments: {
    enableLogs: true,
  },

  // Sample rate for performance monitoring
  tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,

  // Don't send PII
  beforeSend(event) {
    // Strip sensitive data
    if (event.request) {
      delete event.request.cookies;
      delete event.request.headers?.['authorization'];
    }
    return event;
  },

  // Tag errors by vendor
  beforeSendTransaction(event) {
    const vendorId = event.contexts?.vendor?.id;
    if (vendorId) {
      event.tags = { ...event.tags, vendor_id: vendorId };
    }
    return event;
  },
});
```

##### Logger Integration

```typescript
Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  integrations: [
    // Send console.log, console.warn, and console.error calls as logs to Sentry
    Sentry.consoleLoggingIntegration({ levels: ["log", "warn", "error"] }),
  ],
  _experiments: {
    enableLogs: true,
  },
});
```

#### Logger Examples

`logger.fmt` is a template literal function that should be used to bring variables into the structured logs.

```typescript
import * as Sentry from "@sentry/nextjs";
const { logger } = Sentry;

// In API routes or components:
logger.trace("Starting database connection", { database: "users" });
logger.debug(logger.fmt`Cache miss for product: ${productId}`);
logger.info("Order fulfilled", { orderId: "order_123", vendor_id: vendorId });
logger.warn("Rate limit reached for endpoint", {
  endpoint: "/api/vendor/products",
  vendor_id: vendorId,
});
logger.error("Failed to process payment", {
  orderId: "order_123",
  amount: 99.99,
  payment_method: "card",
});
logger.fatal("Database connection pool exhausted", {
  database: "postgres",
  activeConnections: 100,
});
```

### Critical Operations to Monitor

**ALWAYS add Sentry tracking for:**

#### 1. Payment Processing
```typescript
Sentry.startSpan({
  op: "payment.process",
  name: "Process Payment"
}, async (span) => {
  try {
    span.setAttribute("amount", amount);
    span.setAttribute("payment_method", method);
    span.setAttribute("vendor_id", vendorId);

    const result = await processPayment(data);
    return result;
  } catch (error) {
    Sentry.captureException(error, {
      tags: { component: 'payment', severity: 'critical' }
    });
    throw error;
  }
});
```

#### 2. Order Fulfillment
```typescript
Sentry.startSpan({
  op: "order.fulfill",
  name: "Fulfill Order"
}, async (span) => {
  span.setAttribute("order_id", orderId);
  span.setAttribute("vendor_id", vendorId);
  span.setAttribute("location_id", locationId);

  // ... fulfillment logic
});
```

#### 3. Inventory Updates
```typescript
logger.info("Inventory adjusted", {
  product_id: productId,
  location_id: locationId,
  old_quantity: oldQty,
  new_quantity: newQty,
  adjustment_type: type,
  vendor_id: vendorId,
});
```

#### 4. Failed Authentication Attempts
```typescript
logger.warn("Authentication failed", {
  email: email,
  reason: "invalid_credentials",
  ip_address: request.ip,
});
```

#### 5. API Errors
```typescript
// In API routes
try {
  // ... logic
} catch (error) {
  logger.error("API request failed", {
    endpoint: request.url,
    method: request.method,
    vendor_id: vendorId,
    error: error.message,
  });

  Sentry.captureException(error);

  return NextResponse.json(
    { error: "Internal server error" },
    { status: 500 }
  );
}
```

### Performance Monitoring

Track performance for:
- API route handlers
- Database queries
- External API calls
- Complex calculations (pricing engine)

```typescript
// Example: Track pricing calculation performance
async function calculatePriceWithTracking(product, promotions) {
  return Sentry.startSpan({
    op: "pricing.calculate",
    name: "Calculate Product Price"
  }, async (span) => {
    span.setAttribute("product_id", product.id);
    span.setAttribute("promotion_count", promotions.length);

    const result = calculatePrice(product, promotions);

    span.setAttribute("final_price", result.finalPrice);
    span.setAttribute("discount_applied", result.savings > 0);

    return result;
  });
}
```

---

## Security Best Practices

### Authentication & Authorization

**CRITICAL:** NEVER use header-based authentication (`x-vendor-id`).

#### ✅ CORRECT:
```typescript
import { requireVendor } from '@/lib/auth/middleware';

export async function GET(request: NextRequest) {
  // Extract vendor_id from authenticated session
  const authResult = await requireVendor(request);
  if (authResult instanceof NextResponse) return authResult;

  const { user, vendorId } = authResult;

  // Use vendorId for queries...
}
```

#### ❌ WRONG:
```typescript
// NEVER DO THIS - Vulnerable to header spoofing!
const vendorId = request.headers.get('x-vendor-id');
```

### Row Level Security (RLS)

All vendor-scoped database queries MUST be protected by RLS policies:

```sql
-- ✅ CORRECT: RLS policy enforces vendor isolation
CREATE POLICY "Vendors can manage their own promotions"
  ON public.promotions FOR ALL
  USING (vendor_id = (auth.jwt() ->> 'vendor_id')::uuid);

-- ❌ WRONG: Allows all access
CREATE POLICY "Vendors can manage their own promotions"
  ON public.promotions FOR ALL
  USING (true); -- NO! This bypasses security
```

### Input Validation

Always validate inputs with Zod schemas:

```typescript
import { z } from 'zod';

const CreateProductSchema = z.object({
  name: z.string().min(1).max(255),
  price: z.number().positive(),
  vendor_id: z.string().uuid(),
  category_id: z.string().uuid(),
});

export async function POST(request: NextRequest) {
  const body = await request.json();

  // Validate and type-safe
  const validatedData = CreateProductSchema.parse(body);

  // ... use validatedData
}
```

---

