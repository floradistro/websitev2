import { a } from "./chunk-XR65N6EG.js";
var p = {};
function b(e) {
  return [...new Uint8Array(e)]
    .map((t) => {
      let n = t.toString(16);
      return n.length === 1 ? `0${n}` : n;
    })
    .join("");
}
async function* A(e) {
  let t = e.getReader();
  try {
    for (;;) {
      let { done: n, value: r } = await t.read();
      if (n) return;
      yield r;
    }
  } finally {
    t.releaseLock();
  }
}
async function v(e) {
  let t = [],
    n = 0,
    r = 0;
  for await (let o of A(e)) (t.push(o), (n += o.length));
  let a = new Uint8Array(n);
  for (let o of t) (a.set(o, r), (r += o.length));
  return a.buffer;
}
var T = ((r) => (
  (r.VALID = "VALID"),
  (r.INVALID = "INVALID"),
  (r.NOT_VERIFIABLE = "NOT_VERIFIABLE"),
  r
))(T || {});
async function S(e, t, n) {
  if (typeof crypto.subtle.digest != "function")
    return (
      a.log(
        a.Level.Warn,
        `Insecure context (see https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts): The hash of the Scandit Data Capture library WASM file found at ${n} could not be verified`,
      ),
      "NOT_VERIFIABLE"
    );
  try {
    let r = e instanceof Promise ? await e : e,
      a$1 = await crypto.subtle.digest("SHA-256", r),
      o = b(a$1);
    return t == null
      ? (a.log(
          a.Level.Warn,
          "The library hash is not defined or empty, cannot correctly verify integrity.",
        ),
        "NOT_VERIFIABLE")
      : o === t
        ? (a.log(
            a.Level.Debug,
            `Data Capture library WASM integrity found at ${n} has been verified correctly.`,
          ),
          "VALID")
        : (a.log(
            a.Level.Warn,
            `The Scandit Data Capture library WASM file found at ${n} seems invalid: expected file hash doesn't match (received: ${o}, expected: ${t}). Please ensure the correct Scandit Data Capture file (with correct version) is retrieved.`,
          ),
          "INVALID");
  } catch (r) {
    return (
      a.log(a.Level.Warn, "Wasm response could not be verified", r),
      "NOT_VERIFIABLE"
    );
  }
}
var d = new Map([
  ["br", 4.4],
  ["gzip", 2.9],
  ["none", 1],
]);
function I(e) {
  var r;
  let t = "content-encoding";
  if (e == null || e.get(t) == null) return d.get("none");
  let n = new Set(
    ((r = e.get(t)) != null ? r : "").split(",").map((a) => a.trim()),
  );
  for (let [a, o] of d) if (n.has(a)) return o;
  return d.get("none");
}
function L(e) {
  var r, a;
  if (e == null) return 0;
  let t = (r = I(e)) != null ? r : 1,
    n = Number.parseInt((a = e.get("content-length")) != null ? a : "0", 10);
  return Number.isNaN(n) ? 0 : Math.floor(n * t * 100) / 100;
}
function R(e) {
  let { pathname: t } = new URL(e);
  for (let [n, r] of Object.entries(p)) if (t.endsWith(n)) return r.bytes;
  return 0;
}
function N(e) {
  p = e;
}
var w = (e, t) => {
  let n = L(t);
  return n === 0 ? R(e) : n;
};
function B(e, t, n, { onProgress: r, onError: a$1, onComplete: o }) {
  if (!t.body) return [t];
  let f = w(e, t.headers),
    s = 0,
    u = 0;
  if (typeof TransformStream > "u")
    return (
      a.warn(
        "TransformStream is not supported in this environment. Progress tracking will be disabled.",
      ),
      [t]
    );
  let [l, g] = n ? t.body.tee() : [t.body],
    h = l.pipeThrough(
      new TransformStream({
        async transform(c, y) {
          try {
            ((s += c.length),
              (u = Number(((s / f) * 100).toFixed(2))),
              f > 0 && c.length > 0 && u < 100
                ? r == null ||
                  r({ percentage: u, loadedBytes: s, privateUri: e })
                : f === 0 &&
                  c.length > 0 &&
                  (r == null ||
                    r({ percentage: null, loadedBytes: s, privateUri: e })),
              y.enqueue(c));
          } catch (m) {
            (y.error(m), a$1 == null || a$1({ error: m }));
          }
        },
        flush(c) {
          (r == null || r({ percentage: 100, loadedBytes: s, privateUri: e }),
            o == null || o({ percentage: 100, loadedBytes: s, privateUri: e }),
            c.terminate());
        },
      }),
    );
  return [
    new Response(h, {
      headers: new Headers(t.headers),
      status: t.status,
      statusText: t.statusText,
    }),
    g,
  ];
}
async function W({
  wasmURI: e,
  expectedHash: t,
  verifyResponseHash: n,
  onProgress: r,
  onComplete: a,
  onError: o,
  referredOrigin: f,
}) {
  let s = await fetch(e, {
    referrerPolicy: "origin",
    referrer: f != null ? f : "",
  });
  if (!s.ok)
    throw new Error(`HTTP status code is not ok: ${s.status}, ${s.statusText}`);
  let [u, l] = B(e, s, n, { onProgress: r, onError: o, onComplete: a });
  return (l != null && S(v(l), t, e), u);
}
export { T as a, S as b, N as c, w as d, B as e, W as f };
